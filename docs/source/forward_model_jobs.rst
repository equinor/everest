.. _cha_forward_model_jobs:

******************
Forward Model Jobs
******************

Some of the forward models are connected and often the output of one is the
input to another. However, they maintain the same format, and thus a subset
of the jobs can be run independently. For example, if well_constraints is not
necessary, it can be omitted, and if well_order is not a concern, the input to
the well_constraints can be setup and copied (in the everest configuration,
rather than using the drill_planner every time).
Some of them are however mandatory, e.g. the add_templates is a prerequisite
for the schmerge job.

**Example**

.. code-block:: yaml

    forward_model:
      - fm_drill_planner -i well.json
                         -c drill_planner_config.yaml
                         -opt optimizer_values.yml
                         -o wells_dp_result.json
      - fm_well_constraints -i wells_dp_result.json
                            -c well_constraint_config.yml
                            -rc rate_input.json
                            -pc phase_input.json
                            -dc duration_input.json
                            -o wells_wc_result.json
      - fm_add_templates -c template_config.yml
                         -i wells_wc_result.json
                         -o wells_tmpl_result.json
      - fm_schmerge  -s raw_schedule.sch
                     -i wells_tmpl_result.json
                     -o result_schedule.sch

.. _dp:

Drill Planner
=============

.. argparse::
    :module: everest_models.jobs.fm_drill_planner.parser
    :func: build_argument_parser
    :prog: fm_drill_planner

Argument examples
~~~~~~~~~~~~~~~~~
**--input** example (generated by Everest)

.. code-block:: json

    [
     {
       "name": "w1",
       "drill_time": 20
     },
     {
       "name": "w2",
       "drill_time": 25
     },
     {
       "name": "w3",
       "drill_time": 43
     },
     {
       "name": "w4",
       "drill_time": 23
     },
     {
       "name": "w5",
       "drill_time": 36
     }
    ]

**--config** example

.. code-block:: yaml

    start_date: 2000-01-01
    end_date: 2001-01-01
    rigs:
      -
        name: 'A'
        wells: ['w1', 'w2', 'w3']
        slots: ['S1', 'S2', 'S3']
        unavailability:
          -
            start: 2000-01-01
            stop: 2000-02-02
          -
            start: 2000-03-14
            stop: 2000-03-19
      -
        name: 'B'
        wells: ['w3', 'w4', 'w5']
        slots: ['S3', 'S4', 'S5']
        unavailability:
          -
            start: 2000-02-01
            stop: 2000-02-02
          -
            start: 2000-02-14
            stop: 2000-02-15
    slots:
      -
        name: 'S1'
        wells: ['w1', 'w2', 'w3']
        unavailability:
          -
            start: 2000-02-01
            stop: 2000-02-03
      -
        name: 'S2'
        wells: ['w1', 'w2', 'w3']
      -
        name: 'S3'
        wells: ['w1', 'w2', 'w3']
      -
        name: 'S4'
        wells: ['w3', 'w4', 'w5']
      -
        name: 'S5'
        wells: ['w3', 'w4', 'w5']

**--optimizer** example (generated by Everest)

.. code-block:: yaml

    w1: 5
    w2: 4
    w3: 3
    w4: 2
    w5: 1

.. _npv:

Net Present Value
=================

.. argparse::
    :module: everest_models.jobs.fm_npv.parser
    :func: build_argument_parser
    :prog: fm_npv

Argument examples
~~~~~~~~~~~~~~~~~
**--config** example

.. code-block:: yaml

    prices:
        FOPT:
            - { date: 1999-01-01, value: 60, currency: USD }
        FWPT:
            - { date: 1999-01-01, value: -5, currency: USD }
            - { date: 2002-01-01, value: -2 }
        FGPT:
            - { date: 1999-01-01, value: 1, currency: USD }
            - { date: 2002-01-01, value: 0.1 }
        FWIT:
            - { date: 1999-01-01, value: -10, currency: USD }
            - { date: 2002-01-01, value: -20 }
        FGIT:
            - { date: 1999-01-01, value: -0.02, currency: USD }
            - { date: 2002-01-01, value: -0.1 }
        GOPT:OP:
            - { date: 1999-12-10, value: 555 }

    dates:
        start_date: 2000-12-06
        end_date: 2002-12-23
        ref_date: 2000-12-06

    summary_keys: ['FWIT', 'FOPT']

    exchange_rates:
        USD:
            - { date: 1997-01-01, value: 5 }
            - { date: 2000-02-01, value: 7 }
            - { date: 2001-05-01, value: 6 }
            - { date: 2002-02-01, value: 9 }

    discount_rates:
        - { date: 1999-01-01, value: 0.02 }
        - { date: 2002-01-01, value: 0.05 }

    costs:
        - { date: 1999-01-01, value: 10000000, currency: USD }
        - { date: 1999-10-01, value: 20000000 }
        - { date: 1999-10-05, value: 5000000, currency: USD }
        - { date: 2000-01-07, value: 100000000, currency: GBP }
        - { date: 2000-07-25, value: 5000000, currency: NOK }

    well_costs:
        - { well: OP_1, value: 10000000, currency: USD }
        - { well: OP_2, value: 20000000 }
        - { well: OP_3, value: 5000000, currency: USD }
        - { well: OP_4, value: 100000000, currency: GBP }
        - { well: OP_5, value: 1000000 }
        - { well: WI_1, value: 100000, currency: USD }
        - { well: WI_2, value: 20000000, currency: USD }
        - { well: WI_3, value: 5000000, currency: NOK }

**--input** example (generated by Everest)

This argument uses output of the **drill_planner** job, or a similar output.

.. code-block:: json

    [
        {
            "name": "OP_4",
            "readydate": "2000-02-23"
        },
        {
            "name": "OP_5",
            "readydate": "2000-06-14"
        },
        {
            "name": "OP_1",
            "readydate": "2000-07-19"
        }
    ]

.. _rf:

Recovery Factor
===============

.. argparse::
    :module: everest_models.jobs.fm_rf.parser
    :func: build_argument_parser
    :prog: fm_rf

.. _well_constraints:

Well Constraints
================

.. argparse::
    :module: everest_models.jobs.fm_well_constraints.parser
    :func: build_argument_parser
    :prog: fm_well_constraints

Argument examples
~~~~~~~~~~~~~~~~~

Please note that the number of entries and the corresponding indexes for the
configuration file must line up with each of the phase, rate and duration
constraint inputs respectively.

If there is an entry in e.g. the rate-constraint file for `INJECT1`, `1`, then
either `options` must be declared, or a `min`/`max` must be entered in the
configuration file under index `1` for `INJECT1`. For all other entries in the
configuration file that does not exist in any input file, there must exist a
`value` entry that contains a single value.

**--config** example

.. code-block:: yaml

    INJECT1:
        1:
          phase:
            options: [water, gas]
          rate:
            min: 0
            max: 1000
          duration:
            min: 10
            max: 40
        2:
          phase:
            options: [water, gas]
          rate:
            min: 0
            max: 1000
          duration:
            min: 20
            max: 30
        3:
          phase:
            options: [water, gas]
          rate:
            min: 0
            max: 1000
          duration:
            value: 70
        4:
          phase:
            value: water
          rate:
            value: 333
          duration:
            value: 100

    INJECT2:
        1:
          phase:
            options: [water, gas]
          rate:
            min: 500
            max: 1000
          duration:
            value: 50
        2:
          phase:
            options: [water, gas]
          rate:
            min: 500
            max: 1000
          duration:
            value: 60

**--phase-constraint** example

.. code-block:: json

    {
    "INJECT1" : {
      "1": 0.49,
      "2": 0.51,
      "3": 0.8
    },
    "INJECT2" : {
      "1": 0.3,
      "2": 0.1
    }}

**--rate-constraint** example

.. code-block:: json

    {
    "INJECT1" : {
      "1": 0.6,
      "2": 0.4,
      "3": 0.2
    },
    "INJECT2" : {
      "1": 0.123,
      "2": 0.465
    }}

**--duration-constraint** example

.. code-block:: json

    {
    "INJECT1" : {
      "1": 0.6,
      "2": 0.4,
    }}

**--input** example (generated by everest)


.. code-block:: json

    [
      {
        "name": "INJECT1",
        "readydate": "2019-05-12",
        "ops": [
            {"opname": "open", "date": "2019-05-12"}
        ]
      },
      {
        "name": "INJECT2",
        "readydate": "2019-09-15",
        "ops": [
            {"opname": "open", "date": "2019-09-15"}
        ]
      }
    ]

.. _strip_dates:

Strip dates
===========
.. argparse::
    :module: everest_models.jobs.fm_strip_dates.parser
    :func: build_argument_parser
    :prog: fm_strip_dates

.. _well_filter:

Well filter
===========
.. argparse::
    :module: everest_models.jobs.fm_well_filter.parser
    :func: build_argument_parser
    :prog: fm_well_filter


Argument examples
~~~~~~~~~~~~~~~~~
**--input** example (generated by Everest)

.. code-block:: json

    [
      {
        "name": "w1",
        "drill_time": 20
      },
      {
        "name": "w2",
        "drill_time": 25
      },
      {
        "name": "w3",
        "drill_time": 43
      },
      {
        "name": "w4",
        "drill_time": 23
      },
      {
        "name": "w5",
        "drill_time": 36
      }
     ]

**--keep** example

.. code-block:: json

    ["w1", "w3", "w5"]

.. _add_tmpl:

Add templates
=============
.. argparse::
    :module: everest_models.jobs.fm_add_templates.parser
    :func: build_argument_parser
    :prog: fm_add_templates

.. _eclipse100:

Eclipse simulator
=================

.. code-block:: bash

  eclipse100 <eclbase> --version <version_number>

Running eclipse with parallel option
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is possible to run eclipse with multiple CPUs on clusters. This requires the eclipse data file to have the
parallel option and the everest config needs to specify the number of CPUs per node:

.. code-block:: yaml

  simulator:
    cores_per_realization: x

where x is an int giving the number of cores. The eclipse100 forward model also needs to be given the argument to use
multiple cores:

.. code-block:: bash

  eclipse100 <eclbase> --version <version_number> --num-cpu x

where x is the number of cores.

Everest usage example
~~~~~~~~~~~~~~~~~~~~~
The following illustrates an example of a forward model section of an Everest config file:

.. code-block:: yaml

    forward_model:
      - well_constraints  -i files/well_readydate.json -c files/wc_config.yml -rc well_rate.json -o wc_wells.json
      - add_templates     -i wc_wells.json -c files/at_config.yml -o at_wells.json
      - schmerge          -s eclipse/include/schedule/schedule.tmpl -i at_wells.json -o eclipse/include/schedule/schedule.sch
      - eclipse100        r{{ eclbase }} --version 2020.2
      - rf                -s r{{ eclbase }} -o rf_0

The ``add_templates`` job does **NOT** need to be *installed* it is already part of the default everest jobs.
In the example above all files present in the ``files`` folder need to be provided by the user. The ``files``
folder should have the following structure:

.. code-block:: yaml

 files/
    |- well_readydate.json
    |- wc_config.yml
    |- at_config.yml
    |- templates/
        |- wconinje.j2.html
        |- wconprod.j2.html

and should be *installed* in the everest config file:

.. code-block::

    install_data:
      -
        source: r{{ configpath }}/../input/files
        target: files
        link: true

``well_readydate.json``

.. code-block:: json

    [
       {
         "name": "PROD1",
         "readydate": "2000-01-01",
       },
       {
         "name": "PROD2",
         "readydate": "2000-01-01",
       },
       {
         "name": "INJECT1",
         "readydate": "2000-01-01",
       },
       {
         "name": "INJECT2",
         "readydate": "2000-01-01",
       }
    ]

``wc_config.yml``

.. code-block:: yaml

    PROD1:
      1:
        phase:
          value: OIL
        rate:
          min: 500
          max: 1000
        duration:
          value: 50
    PROD2:
      1:
        phase:
          value: OIL
        rate:
          min: 800
          max: 1400
        duration:
          value: 50
    INJECT1:
      1:
        phase:
          value: WATER
        rate:
          min: 5000
          max: 10000
        duration:
          value: 50
    INJECT2:
      1:
        phase:
          value: WATER
        rate:
          min: 5000
          max: 10000
        duration:
          value: 50

``at_config.yml``

.. code-block:: yaml

    templates:
      -
        file: './files/templates/wconinje.j2.html'
        keys:
            opname: rate
            phase: WATER
      -
        file: './files/templates/wconprod.j2.html'
        keys:
            opname: rate
            phase: OIL

``wconprod.j2.html``

.. code-block:: jinja

    WCONPROD
      '{{ name }}'  'OPEN'  'ORAT' {{ rate }}   4* 100   /
    /

``wconinje.j2.html``

.. code-block:: jinja

    WCONINJE
      '{{ name }}'  '{{ phase }}'  'OPEN'  'RATE' {{ rate }}   1* 320  1*  1*    1*   /
    /

In the above example of the forward model section of the config file:

* The file ``wc_wells.json`` is a direct output of the ``well_constraint`` job.
* The ``add_templates`` job uses the same file ``wc_wells.json`` as an input for the job.
* The ``wc_wells.json`` file is not modified by the user. Any modification to this file should be done using a custom job (see the section :ref:`cha_creating_custom_jobs` for more information on how to do that).

If the file is to be modified by a custom job, the everest config should contain:

.. code-block:: yaml

    install_jobs:
      -
        name: custom_job
        source: jobs/CUSTOM_JOB_CONFIG

    forward_model:
      - well_constraints  -i files/well_readydate.json -c files/wc_config.yml -rc well_rate.json -o wc_wells.json
      - custom_job        -i wc_wells.json -o wc_wells_custom.json
      - add_templates     -i wc_wells_custom.json -c files/at_config.yml -o at_wells.json
      - schmerge          -s eclipse/include/schedule/schedule.tmpl -i at_wells.json -o eclipse/include/schedule/schedule.sch
      - eclipse100        r{{ eclbase }} --version 2020.2
      - rf                -s r{{ eclbase }} -o rf_0


``wc_wells.json``

.. code-block:: json

    [
      {
        "name": "PROD1",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "OIL",
            "rate": 550.0015,
            "date": "2000-01-01",
            "opname": "rate"
          }
        ]
      },
      {
        "name": "PROD2",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "OIL",
            "rate": 860.0048,
            "date": "2000-01-01",
            "opname": "rate"
          }
        ]
      },
      {
        "name": "INJECT1",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "WATER",
            "rate": 5499.93,
            "date": "2000-01-01",
            "opname": "rate"
          }
        ]
      },
      {
        "name": "INJECT2",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "WATER",
            "rate": 5500.075,
            "date": "2000-01-01",
            "opname": "rate"
          }
        ]
      }
    ]

The add_templates job will search in the file ``wc_wells.json`` for the keys defined by the user in the config file ``at_config.yml``
and where the keys are present the job will add the corresponding template file.  The resulting output ``at_wells.json`` has the following form:

``at_wells.json``

.. code-block:: json

    [
      {
        "name": "PROD1",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "OIL",
            "rate": 550.0015,
            "date": "2000-01-01",
            "opname": "rate",
            "template": "./files/templates/wconprod.j2.html"
          }
        ]
      },
      {
        "name": "PROD2",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "OIL",
            "rate": 860.0048,
            "date": "2000-01-01",
            "opname": "rate",
            "template": "./files/templates/wconprod.j2.html"
          }
        ]
      },
      {
        "name": "INJECT1",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "WATER",
            "rate": 5499.93,
            "date": "2000-01-01",
            "opname": "rate",
            "template": "./files/templates/wconinje.j2.html"
          }
        ]
      },
      {
        "name": "INJECT2",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "WATER",
            "rate": 5500.075,
            "date": "2000-01-01",
            "opname": "rate",
            "template": "./files/templates/wconinje.j2.html"
          }
        ]
      }
    ]

Next, the ``at_wells.json`` file is used as an input for the schedule merge job ``schmerge`` together with the initial schedule template
``schedule.tmpl`` file, which will result in the new schedule file ``schedule.sch`` used for the simulation.

For the following entry in the ``at_wells.json``:

.. code-block:: json

      {
        "name": "PROD1",
        "readydate": "2000-01-01",
        "ops": [
          {
            "phase": "OIL",
            "rate": 550.0015,
            "date": "2000-01-01",
            "opname": "rate",
            "template": "./files/templates/wconprod.j2.html"
          }
        ]
      }

and the template ``wconprod.j2.html``:

.. code-block:: jinja

    WCONPROD
      '{{ name }}'  'OPEN'  'ORAT' {{ rate }}   4* 100   /
    /

the resulting entry in ``schedule.sch`` is as follows:

.. code-block::

    DATES
     01 JAN 2000 / --ADDED
    /

    --start ./files/templates/wconprod.j2.html
    WCONPROD
      'PROD1'  'OPEN'  'ORAT' 550.0015   4* 100   /
    /

    --end ./files/templates/wconprod.j2.html

where ``"--"`` marks the beginning of a comment line and will be ignored by the simulator.


Other template examples
^^^^^^^^^^^^^^^^^^^^^^^
The `jinja2 <https://jinja.palletsprojects.com/>`_ templating language is supported by
the schedule merge job, and can be used to write the templates.
Below a few default examples can be found:

**Water injection template**

.. code-block:: jinja

    WCONINJE
      '{{ name }}' '{{ phase }}' 'OPEN' 'RATE' {{ rate }} 5*   /
    /

**Gas production template**

.. code-block:: jinja

    WCONPROD
      '{{ name }}' 'OPEN' 'GRAT' {{ rate }}  5*   /
    /

**Oil production template**

.. code-block:: jinja

    WCONPROD
      '{{ name }}' 'OPEN' 'ORAT' {{ rate }}  5*  /
    /

**Well open template**

.. code-block:: jinja

    WELOPEN
      '{{ name }}' 'OPEN' /
    /

More information regarding template design and usage can be found `here <https://jinja.palletsprojects.com/templates/>`_.

.. _schmerge:

Schedule merge
==============

.. argparse::
    :module: everest_models.jobs.fm_schmerge.parser
    :func: build_argument_parser
    :prog: fm_schmerge

Argument examples
~~~~~~~~~~~~~~~~~

**--input** example

.. code-block:: python

    -- Dummy schedule file - but we try to add a typical set up

    WELSPECS
    -- Item #: 1	 2	3	4	5	 6
        'PROD1'	'G1'	10	10	8400	'OIL' /
        'PROD2'	'G1'	10	9	8400	'OIL' /
        'PROD3'	'G1'	10	8	8400	'OIL' /
        'INJ1'	'G1'	1	1	8335	'GAS' /
        'INJ2'	'G1'	1	2	8335	'GAS' /
    /

    COMPDAT
    -- Item #: 1	2	3	4	5	6	7	8	9
        'PROD1'	10	10	3	3	'CLOSE'	1*	1*	0.5 /
        'PROD2'	10	9	3	3	'CLOSE'	1*	1*	0.5 /
        'PROD3'	10	8	3	3	'CLOSE'	1*	1*	0.5 /
        'INJ1'	1	1	1	1	'CLOSE'	1*	1*	0.5 /
        'INJ2'	1	2	1	1	'CLOSE'	1*	1*	0.5 /
    /

    RPTRST
       BASIC=3 FREQ=3 /

    DATES
     01 JAN 2000 /
    /

    DATES
     01 FEB 2001 /
    /

    DATES
     01 MAR 2002 /
    /



**--config** example (generated by previous job)

This argument uses output of the **add_templates** and possibly **well_constraints** jobs, or similar output.

.. code-block:: yaml

    [
        {
            "name": "INJECT5",
            "ops": [{
                        "opname": "open",
                        "date": "2016-05-19",
                        "template": "files/welopen.jinja"
                   }]
        },
        {
            "name": "INJECT7",
            "ops": [{
                        "opname": "wconinje",
                        "date": "2000-01-01",
                        "template": "files/wconinje.jinja",
                        "rate": "0.7",
                        "phase": "WATER"
                   }]
        },
        {
            "name": "PROD3",
            "ops": [{
                        "opname": "open",
                        "date": "2016-05-20",
                        "template": "files/welopen.jinja"
                   }]
        },
        {
            "name": "INJECT3",
            "ops": [{
                        "opname": "wcqonje",
                        "date": "2021-04-24",
                        "template": "files/wconinje.jinja",
                        "rate": "0.55",
                        "phase": "GAS"
                   }]
        },
        {
            "name": "INJECT1",
            "ops": [{
                        "opname": "open",
                        "date": "2020-01-28",
                        "template": "files/welopen.jinja"
                   }]
        },
        {
            "name": "PROD1",
            "ops": [{
                        "opname": "open",
                        "date": "2021-04-23",
                        "template": "files/welopen.jinja"
                   }]
        }
    ]


.. _stea:

Stea
====

.. argparse::
    :module: everest_models.jobs.fm_stea.parser
    :func: build_argument_parser
    :prog: fm_stea

Argument examples
~~~~~~~~~~~~~~~~~

**--config** example

.. code-block:: yaml

    # The id of the project, which must already exist and be available in
    # the stea database. In the Stea documentation this is called "AlternativeId".
    project-id: 4782
    project-version: 1


    # All information in stea is versioned with a timestamp. When we request a
    # calculation we must specify wich date we wish to use to fetch configuration
    # information for assumptions like e.g. the oil price.
    config-date: 2018-07-01 12:00:00


    # The stea web client works by *adjusting* the profiles in an existing
    # stea project which has already been defined. That implies that all
    # profiles added in this configuration file should already be part of
    # the project. To match the profiles specified here with the profiles in
    # the project we must give a id for the profiles.

    # The profiles keyword is used to enter profile data explicitly in the
    # configuration file. Each profile is identified with an id from the
    # existing stea project, a start date and the actual data.

    profiles:
        <ecl_profile_id>:
           start-year: 2018
           data: [100, 200, 300]

    # Profiles which are calculated directly from an eclipse simulation are
    # listed with the ecl-profiles key. Each profile is identified with an id
    # from the stea project and an eclipe key like 'FOPT'. By default the stea
    # client will calculate a profile from the full time range of the simulated
    # data, but you can optionally use the keywords start-year and end-year to
    # limit the time range.
    ecl-profiles:
      <ecl_profile_id>:
         ecl-key: FOPT

      <ecl_profile_id>:
         ecl-key: FGPT
         start-year: 2020
         end-year: 2030

      profile_comment_in_stea:
         ecl-key: FWPT
         glob_mult: 1.1

      another_profile_comment_in_stea:
         ecl-key: FWPT
         mult: [ 1.1, 2, 0 ]

    # What do you want stea to calculate
    results:
       - NPV

.. _extract_sd:

Extract summary data
====================

.. argparse::
    :module: everest_models.jobs.fm_extract_summary_data.parser
    :func: build_argument_parser
    :prog: fm_extract_summary_data
